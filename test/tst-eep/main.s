;
; File generated by cc65 v 2.13.3
;
	.fopt		compiler,"cc65 v 2.13.3"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank, tmp1, ptr1, ptr2
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_gfx_vsync
	.import		_gfx_init
	.export		_gfxOn
	.export		_gfxOff
	.export		_setScroll
	.export		_ppuSetAddr
	.export		_strCopy
	.export		_joyRead
	.export		_printHex
	.export		_eep
	.export		_eep_start
	.export		_eep_stop
	.export		_eep_tx
	.export		_main

.segment	"RODATA"

L0001:
	.byte	$4D,$45,$4D,$20,$53,$49,$53,$45,$20,$00

.segment	"BSS"

_eep:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ gfxOn (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_gfxOn: near

.segment	"CODE"

;
; gfx_vsync();
;
	ldy     #$00
	jsr     _gfx_vsync
;
; PPU_MASK = 0x0A;
;
	lda     #$0A
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ gfxOff (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_gfxOff: near

.segment	"CODE"

;
; gfx_vsync();
;
	ldy     #$00
	jsr     _gfx_vsync
;
; PPU_MASK = 0;
;
	lda     #$00
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ setScroll (unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setScroll: near

.segment	"CODE"

;
; PPU_ADDR = 0;
;
	lda     #$00
	sta     $2006
;
; PPU_SCROLL = y;
;
	tay
	lda     (sp),y
	sta     $2005
;
; PPU_SCROLL = x;
;
	iny
	lda     (sp),y
	sta     $2005
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ ppuSetAddr (unsigned short)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppuSetAddr: near

.segment	"CODE"

;
; PPU_ADDR = addr >> 8;
;
	jsr     ldax0sp
	stx     $2006
;
; PPU_ADDR = addr & 0xff;
;
	ldy     #$00
	lda     (sp),y
	sta     $2006
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ strCopy (__near__ unsigned char*)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_strCopy: near

.segment	"CODE"

;
; while (*src)PPU_DATA = *src++;
;
L0117:	jsr     ldax0sp
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	jeq     incsp2
	jsr     ldax0sp
	sta     regsave
	stx     regsave+1
	jsr     incax1
	jsr     stax0sp
	ldy     #$00
	lda     (regsave),y
	sta     $2007
	jmp     L0117

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ joyRead (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_joyRead: near

.segment	"CODE"

;
; u8 joy = 0;
;
	lda     #$00
	jsr     pusha
;
; JOY_PORT = 0x01;
;
	jsr     decsp1
	lda     #$01
	sta     $4016
;
; JOY_PORT = 0x00;
;
	lda     #$00
	sta     $4016
;
; for (i = 0; i < 8; i++) {
;
	tay
L014E:	sta     (sp),y
	cmp     #$08
	bcs     L0141
;
; joy <<= 1;
;
	iny
	lda     (sp),y
	asl     a
	sta     (sp),y
;
; joy |= JOY_PORT & 1;
;
	lda     $4016
	and     #$01
	ora     (sp),y
	sta     (sp),y
;
; for (i = 0; i < 8; i++) {
;
	dey
	lda     (sp),y
	clc
	adc     #$01
	jmp     L014E
;
; return joy;
;
L0141:	iny
	ldx     #$00
	lda     (sp),y
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ printHex (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printHex: near

.segment	"CODE"

;
; buff[0] = val >> 4;
;
	jsr     decsp3
	ldy     #$03
	ldx     #$00
	lda     (sp),y
	jsr     asrax4
	ldy     #$00
	sta     (sp),y
;
; buff[1] = val & 15;
;
	ldy     #$03
	lda     (sp),y
	and     #$0F
	ldy     #$01
	sta     (sp),y
;
; buff[2] = 0;
;
	lda     #$00
	iny
	sta     (sp),y
;
; buff[0] = buff[0] < 10 ? buff[0] + '0' : buff[0] - 10 + 'A';
;
	tay
	lda     (sp),y
	cmp     #$0A
	bcs     L0104
	ldx     #$00
	lda     (sp),y
	ldy     #$30
	jmp     L014F
L0104:	ldx     #$00
	lda     (sp),y
	ldy     #$0A
	jsr     decaxy
	ldy     #$41
L014F:	jsr     incaxy
	ldy     #$00
	sta     (sp),y
;
; buff[1] = buff[1] < 10 ? buff[1] + '0' : buff[1] - 10 + 'A';
;
	iny
	lda     (sp),y
	cmp     #$0A
	bcs     L010E
	ldx     #$00
	lda     (sp),y
	ldy     #$30
	jmp     L0150
L010E:	ldx     #$00
	lda     (sp),y
	ldy     #$0A
	jsr     decaxy
	ldy     #$41
L0150:	jsr     incaxy
	ldy     #$01
	sta     (sp),y
;
; strCopy(buff);
;
	lda     sp
	ldx     sp+1
	jsr     pushax
	jsr     _strCopy
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ eep_start (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_eep_start: near

.segment	"CODE"

;
; EEP_WR = EEP_DAT | EEP_CLK;
;
	lda     #$60
	sta     $800D
;
; EEP_WR = EEP_CLK;
;
	lda     #$20
	sta     $800D
;
; eep = EEP_CLK;
;
	sta     _eep
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ eep_stop (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_eep_stop: near

.segment	"CODE"

;
; EEP_WR = EEP_CLK;
;
	lda     #$20
	sta     $800D
;
; EEP_WR = EEP_CLK | EEP_DAT;
;
	lda     #$60
	sta     $800D
;
; eep = EEP_CLK | EEP_DAT;
;
	sta     _eep
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ eep_tx (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_eep_tx: near

.segment	"CODE"

;
; for (i = 0; i < 8; i++) {
;
	jsr     decsp2
	lda     #$00
	ldy     #$01
L0151:	sta     (sp),y
	cmp     #$08
	bcs     L0016
;
; bit = (dat & 0x80) ? EEP_DAT : 0;
;
	iny
	lda     (sp),y
	and     #$80
	beq     L0022
	lda     #$40
L0022:	ldy     #$00
	sta     (sp),y
;
; EEP_WR = bit;
;
	sta     $800D
;
; EEP_WR = bit | EEP_CLK;
;
	lda     (sp),y
	ora     #$20
	sta     $800D
;
; EEP_WR = bit;
;
	lda     (sp),y
	sta     $800D
;
; dat <<= 1;
;
	ldy     #$02
	lda     (sp),y
	asl     a
	sta     (sp),y
;
; for (i = 0; i < 8; i++) {
;
	dey
	lda     (sp),y
	clc
	adc     #$01
	jmp     L0151
;
; EEP_WR = EEP_DAT;
;
L0016:	lda     #$40
	sta     $800D
;
; EEP_WR = EEP_DAT | EEP_CLK;
;
	lda     #$60
	sta     $800D
;
; EEP_WR = EEP_DAT | EEP_DIR;
;
	lda     #$C0
	sta     $800D
;
; bit = EEP_RD & 0x10;
;
	lda     $6000
	and     #$10
	dey
	sta     (sp),y
;
; EEP_WR = EEP_DAT;
;
	lda     #$40
	sta     $800D
;
; return bit;
;
	ldx     #$00
	lda     (sp),y
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; eep = EEP_DAT | EEP_CLK;
;
	jsr     decsp6
	lda     #$60
	sta     _eep
;
; gfx_init();
;
	ldy     #$00
	jsr     _gfx_init
;
; ppuSetAddr(0x3F03);
;
	ldx     #$3F
	lda     #$03
	jsr     pushax
	jsr     _ppuSetAddr
;
; PPU_DATA = 0x27; //0x05;
;
	lda     #$27
	sta     $2007
;
; ppuSetAddr(0x3F07);
;
	ldx     #$3F
	lda     #$07
	jsr     pushax
	jsr     _ppuSetAddr
;
; PPU_DATA = 0x09;
;
	lda     #$09
	sta     $2007
;
; ppuSetAddr(0x3F0B);
;
	ldx     #$3F
	lda     #$0B
	jsr     pushax
	jsr     _ppuSetAddr
;
; PPU_DATA = 0x01;
;
	lda     #$01
	sta     $2007
;
; ppuSetAddr(0x3F0F);
;
	ldx     #$3F
	lda     #$0F
	jsr     pushax
	jsr     _ppuSetAddr
;
; PPU_DATA = 0x27;
;
	lda     #$27
	sta     $2007
;
; PPU_CTRL = 1 << 4; //select bg pattern
;
	lda     #$10
	sta     $2000
;
; ppuSetAddr(0x2000);
;
	ldx     #$20
	lda     #$00
	jsr     pushax
	jsr     _ppuSetAddr
;
; for (i = 0; i < 960; i++)PPU_DATA = ' ';
;
	ldx     #$00
	txa
L015D:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	cmp     #$03
	bne     L0063
	dey
	lda     (sp),y
	cmp     #$C0
L0063:	bcs     L005D
	lda     #$20
	sta     $2007
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L015D
;
; for (i = 0; i < 64; i++)PPU_DATA = 0;
;
L005D:	ldx     #$00
	txa
L015E:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	bne     L006F
	dey
	lda     (sp),y
	cmp     #$40
L006F:	bcs     L0069
	lda     #$00
	sta     $2007
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L015E
;
; for (i = 0; i < 960; i++)PPU_DATA = ' ';
;
L0069:	ldx     #$00
	txa
L015F:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	cmp     #$03
	bne     L007B
	dey
	lda     (sp),y
	cmp     #$C0
L007B:	bcs     L0075
	lda     #$20
	sta     $2007
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L015F
;
; for (i = 0; i < 64; i++)PPU_DATA = 0;
;
L0075:	ldx     #$00
	txa
L0160:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	bne     L0087
	dey
	lda     (sp),y
	cmp     #$40
L0087:	bcs     L0081
	lda     #$00
	sta     $2007
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L0160
;
; for (i = 0; i < 960; i++)PPU_DATA = ' ';
;
L0081:	ldx     #$00
	txa
L0161:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	cmp     #$03
	bne     L0093
	dey
	lda     (sp),y
	cmp     #$C0
L0093:	bcs     L008D
	lda     #$20
	sta     $2007
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L0161
;
; for (i = 0; i < 64; i++)PPU_DATA = 0;
;
L008D:	ldx     #$00
	txa
L0162:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	bne     L009F
	dey
	lda     (sp),y
	cmp     #$40
L009F:	bcs     L0099
	lda     #$00
	sta     $2007
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L0162
;
; for (i = 0; i < 960; i++)PPU_DATA = ' ';
;
L0099:	ldx     #$00
	txa
L0163:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	cmp     #$03
	bne     L00AB
	dey
	lda     (sp),y
	cmp     #$C0
L00AB:	bcs     L00A5
	lda     #$20
	sta     $2007
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L0163
;
; for (i = 0; i < 64; i++) {
;
L00A5:	ldx     #$00
	txa
L0164:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	bne     L00B7
	dey
	lda     (sp),y
	cmp     #$40
L00B7:	bcs     L00B1
;
; if (i == 8) {
;
	ldy     #$05
	lda     (sp),y
	bne     L00B9
	dey
	lda     (sp),y
	cmp     #$08
	bne     L00B9
;
; PPU_DATA = 0x45;
;
	lda     #$45
;
; continue;
;
	jmp     L0152
;
; if (i == 16) {
;
L00B9:	ldy     #$05
	lda     (sp),y
	bne     L00BF
	dey
	lda     (sp),y
	cmp     #$10
	bne     L00BF
;
; PPU_DATA = 0x2a;
;
	lda     #$2A
;
; continue;
;
	jmp     L0152
;
; PPU_DATA = 0;
;
L00BF:	lda     #$00
L0152:	sta     $2007
;
; for (i = 0; i < 64; i++) {
;
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L0164
;
; ptr = (u8 *) 0x6000;
;
L00B1:	ldx     #$60
	lda     #$00
	jsr     stax0sp
;
; for (i = 0; i < 8; i++)ptr[i] = i;
;
	tax
L0165:	ldy     #$04
	jsr     staxysp
	ldy     #$05
	lda     (sp),y
	bne     L00D1
	dey
	lda     (sp),y
	cmp     #$08
L00D1:	bcs     L00CB
	ldy     #$05
	jsr     ldaxysp
	clc
	ldy     #$00
	adc     (sp),y
	sta     ptr1
	txa
	iny
	adc     (sp),y
	sta     ptr1+1
	ldy     #$04
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	jmp     L0165
;
; ppuSetAddr(0x2000 + 32 * 2);
;
L00CB:	ldx     #$20
	lda     #$40
	jsr     pushax
	jsr     _ppuSetAddr
;
; strCopy("MEM SISE ");
;
	lda     #<(L0001)
	ldx     #>(L0001)
	jsr     pushax
	jsr     _strCopy
;
; *(u8 *) 0x800D = 0xff;
;
	lda     #$FF
	sta     $800D
;
; printHex(*(u8 *) 0x800D);
;
	jsr     pusha
	jsr     _printHex
;
; setScroll(0, 0);
;
	lda     #$00
	jsr     pusha
	jsr     pusha
	jsr     _setScroll
;
; gfxOn();
;
	ldy     #$00
	jsr     _gfxOn
;
; i = 16;
;
	ldx     #$00
	lda     #$10
	ldy     #$04
	jsr     staxysp
;
; i = 0;
;
	txa
	ldy     #$04
	jsr     staxysp
;
; i++;
;
L00E9:	ldy     #$05
	jsr     ldaxysp
	jsr     incax1
	ldy     #$04
	jsr     staxysp
;
; for (u = 0; u < 60; u++)gfx_vsync();
;
	ldx     #$00
	txa
L0166:	ldy     #$02
	jsr     staxysp
	ldy     #$03
	lda     (sp),y
	bne     L00F2
	dey
	lda     (sp),y
	cmp     #$3C
L00F2:	bcs     L00E9
	ldy     #$00
	jsr     _gfx_vsync
	ldy     #$03
	jsr     ldaxysp
	jsr     incax1
	jmp     L0166

.endproc

